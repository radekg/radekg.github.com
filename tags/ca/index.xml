<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ca on gruchalski.com</title>
    <link>https://gruchalski.com/tags/ca/</link>
    <description>Recent content in ca on gruchalski.com</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 28 Mar 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://gruchalski.com/tags/ca/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>firebuild rootfs - gRPC with mTLS</title>
      <link>https://gruchalski.com/posts/2021-03-28-firebuild-rootfs-grpc-with-mtls/</link>
      <pubDate>Sun, 28 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://gruchalski.com/posts/2021-03-28-firebuild-rootfs-grpc-with-mtls/</guid>
      <description>the problem Currently, when a rootfs is built, the guest is started with an SSH server and the bootstrap process executes via an SSH connection. I don&amp;rsquo;t like this and want to replace the SSH method with an MMDS based solution. MMDS is already present in the firebuild run command.
run uses the vminit component from firebuild-mmds. When the guest starts, the vminit guest service connects to the MMDS endpoint, downloads the metadata and configures the VM.</description>
    </item>
    
    <item>
      <title>Multi-tenant Vault PKI with custom root PEM bundles</title>
      <link>https://gruchalski.com/posts/2020-09-09-multi-tenant-vault-pki-with-custom-root-pem-bundle/</link>
      <pubDate>Wed, 09 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://gruchalski.com/posts/2020-09-09-multi-tenant-vault-pki-with-custom-root-pem-bundle/</guid>
      <description>In the previous article1, I have investigated modern PKI software alternatives. One of the options on the list was HashiCorp Vault. The natural next step is to set up a Vault PKI.
This article documents setting up an imaginary multi-tenant Vault PKI with custom PEM bundles generated with OpenSSL. The steps the following:
 create a root CA with OpenSSL create intermediate CAs for imaginary clients with OpenSSL using HashiCorp Vault in development mode:  import custom bundle with root and intermediate certificates configure Vault roles issue a certificate    The method for generating the root and intermediate CAs comes from OpenSSL Certificate Authority guide written by Jamie Nguyen2.</description>
    </item>
    
    <item>
      <title>Certificate Authority is not Voodoo</title>
      <link>https://gruchalski.com/posts/2020-09-07-certificate-authority-is-not-voodoo/</link>
      <pubDate>Mon, 07 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://gruchalski.com/posts/2020-09-07-certificate-authority-is-not-voodoo/</guid>
      <description>Modern applications tend to get fairly complex pretty quick. A usual stack will consist of many moving parts. Starting from a cloud environment, maybe abstracted behind Kubernetes or Mesos, through multitude of web servers, GRPC services, to monitoring systems like Grafana, Jaeger, Prometheus, all fronted with load balancers or proxies like Traefik. Many of these components have fairly complex dependencies, ETCD or Zookeeper come to mind. All these power a highly dynamic environment where containers and virtual machines iterate and get replaced often.</description>
    </item>
    
  </channel>
</rss>
